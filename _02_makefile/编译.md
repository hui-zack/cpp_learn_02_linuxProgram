[toc]    
    [GCC基本使用](#GCC基本使用)

## GCC基本使用
**gcc编译四步骤**
```markdown
                预处理            编译            汇编             链接
        hello.c  ----> hello.i  ---->  hello.s  ----> hello.o  <----> a.out
                gcc -E          gcc -S          gcc -c        不指定前三个

```
        预处理: 
            展开宏, 头文件
            替换条件编译
            删除注释, 空行和空白
        编译:
            检查语法规范, 将代码转换为汇编语言
        汇编:
            将汇编语言转化为机器指令
        
        链接: 
            数据段合并, 数据地址回填


**gcc常用参数/编译库文件**    

-   [编译库文件时指定头文件]
```shell
    g++ -c hello.cpp -o a.out -I/home/hui/hello.h    # 当头文件和源码在相同目录时无需指定头文件
```

-   [编译c++代码为可执行文件]   
```shell
    g++ hello.cpp -o hello
```

----
    需要掌握:
        -v                          // 参看版本
        -I[hedersDir]               // 指定头文件目录, 注意I和目录中间没有空格
        -c                          // 执行预处理编译和汇编, 得到库文件(没有链接内容, 不可执行)
        -g                          // 编译时添加可调试功能
        -D[DEF]                     // 编译时定义宏
    需要了解:
        -On n=[0~3]                 // 编译优化, n为3时优化最多(但可以优化/删除有用的代码)
        -Wall                       // 打印所有警告信息 
        -E                          // 生成预处理语句

## 静态库


**制作和使用静态库**
-   [1-1 将hello.cpp制作为静态库]
```shell
    #  _02_makefile/_01_staticLib/resource目录下
    
    gcc -c add.cpp -o add.o                 # 制作add.cpp的机器指令文件add.o
    gcc -c sub.cpp -o sub.o                 # 制作sub.cpp的机器指令文件sub.o
    ar rcs ../libMyMath.a add.o sub.o        # 将add.o和sub.o制作为静态库文件libMyMath.a

``` 
-   [1-2 在cpp代码中使用静态库]
        [1-2-1 声明静态库的函数然后使用](./_01_staticLib/useStaticLib.cpp)
    
-   [1-3 使用gcc编译代码+静态库形成可执行文件]
```shell
    # _02_makefile/_01_staticLib目录下
    g++ useStaticLib.cpp libMyMath.a -o useStaticLib.exe

```
---
    静态库的制作具有规范, 必须以lib开头, .a/.lib结尾

**静态库和动态库的区别**

    静态库会直接编译到程序的可执行文件中
        如果写了两个程序, 每个程序都调用了同一个静态库, 那两个程序都会包含一份这个静态库的代码
        调用静态库更加快一点, 性能更高
    动态库不会编译到程序的可执行文件中
        如果写了两个程序, 每个程序都调用了同一个动态库, 那两个程序都不包含这个动态库的代码
        -但是, 如果动态库被删掉了, 那这两个程序都无法运行
        调用动态库内容要慢一点, 性能要差一点
